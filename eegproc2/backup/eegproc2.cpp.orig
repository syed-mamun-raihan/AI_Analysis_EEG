/***************************************************************************
 *   Copyright (C) 2006 by Syed Mamun Raihan   				   *
 *   $Author$ Syed Mamun Raihan						   *
 *    sraihan@uwo.ca   							   *
 ***************************************************************************/


#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <iostream>
#include <cstdlib>
#include <fstream>
#include <string>
#include <sstream>
#include <cmath>
#include <memory>
#include <ctime>
#include <complex>
#include "fftw3.h"

#include "eegproc2.h"

#if defined(WIN32)

static void my_fftw_write_char(char c, void *f) { fputc(c, (FILE *) f); }
#define fftw_export_wisdom_to_file(f) fftw_export_wisdom(my_fftw_write_char, (void*) (f))
#define fftwf_export_wisdom_to_file(f) fftwf_export_wisdom(my_fftw_write_char, (void*) (f))
#define fftwl_export_wisdom_to_file(f) fftwl_export_wisdom(my_fftw_write_char, (void*) (f))

static int my_fftw_read_char(void *f) { return fgetc((FILE *) f); }
#define fftw_import_wisdom_from_file(f) fftw_import_wisdom(my_fftw_read_char, (void*) (f))
#define fftwf_import_wisdom_from_file(f) fftwf_import_wisdom(my_fftw_read_char, (void*) (f))
#define fftwl_import_wisdom_from_file(f) fftwl_import_wisdom(my_fftw_read_char, (void*) (f))

#endif

using namespace std;
using namespace eegproc2;

#define INIT_DEBUG_PRINT()	static bool firstTime = true;

#define EXEC_DEBUG_PRINT(data,length,file) \
		if (firstTime && m_args.m_boolDebug == true) \
		{\
			cout<<"writing\t" << file <<endl; \
			this->p_DebugWrite(data,file,length);\
		}
#define FINALIZE_DEBUG_PRINT() firstTime = false;

#define TEST_IGNORE_CHANNEL(x,y) \
			bool l_skip; \
			l_skip = false; \
			for(int j=0; j < m_args.m_noOfIgnores;j++){ \
				if(x == m_args.m_ignores[j] || \
					y == m_args.m_ignores[j]){ \
					l_skip = true; \
				} \
			} \
			if(l_skip)continue;
// This is the longerpolated value
#define INTERPOLATE_FEATURE(x,val) \
		this->p_PolyFit (x_cord, \
					x, \
					m_args.m_noOfsamples, \
					1, l_result); \
		val =  \
		l_result[1]*x_cord[m_args.m_noOfsamples]/2 +l_result[0];

void usage(){
	cout
	<< "\nHelp on command line option\n"
	<< "================================================\n"
	<< "<debug/release> <operation> <file> <decimation> "
	<< "<uV/mV> <totals> <ignores>\n"
	<< "================================================\n"
	<< "<file>: file name with directory & extension\n"
	<< "<Operation>: Trend, Dump, Raw, Single \n"
	<< "<decimation>: rate at which samples should be "
	<< "decimated like, 1 in every 2 samples is 2\n"
	<< "<uV/mV>if uV then use 1 otherwise use appropriate a_mvFactor\n"
	<< "<totals>: no of total channels (max: "<< noOfChannels <<")\n"
	<< "<a_ignores>: channels to ignore\n\n"
	<< "\n------------------Split Help --------------\n"
	<< "<file1> <date> <hour> <channels to sample> "
	<< "\n===========================================\n"
	<< "\nWARNING! In many options no check has been made\n\n";
	exit(0);
}

time_t g_startTime;
time_t g_endTime;

int
main (int argc, char *argv[])
{
	const int lc_minArgs = 2;
	if(argc < lc_minArgs){
		usage();
		// call dialog
	}

	Arguments l_args;

	const char* lc_Ops = argv[2];

	// ProcessArguments
	if(strcmp(lc_Ops,"Trend") == 0 ||
		strcmp(lc_Ops,"Dump") == 0 ||
		strcmp(lc_Ops,"Raw") == 0 ||
		strcmp(lc_Ops,"Single") == 0)
	{
		l_args.ProcessGenericArgs(argc, argv);
	}//---------
	else if(strcmp(lc_Ops,"Split") == 0){
		l_args.ProcessSplitDirect(argc, argv);
		return 0;
	}//----------
	else {
		cout << "invalid operation: "<< lc_Ops << endl;
		exit(0);
	}

	RawEEGData l_objData (l_args);

	// Do the Job
	// Sum of Spectrum or Cepstrum or Relative Alpha using AR Model
	if(l_objData.m_args.m_operationType == TREND)
	{
		l_objData.Process ();
	}//----------
	else if(strcmp(lc_Ops,"Dump") == 0){
		l_objData.ProcessDump ();
	}//------------
	else if(strcmp(lc_Ops,"Raw") == 0){
		l_objData.ProcessRaw ();
	}//----------
	else if(strcmp(lc_Ops,"Single") == 0){
		l_objData.ProcessSingle ();
	}//-------------
	else{
		cout << "invalid a_operation: "<< lc_Ops << endl;
		exit(0);
	}

	l_objData.finalize();

	return EXIT_SUCCESS;
}

namespace eegproc2
{
	const double
	RawEEGData::m_A[] =
	{1.0000000000000000e+00,	  -3.5794347983311887e+00,
	   5.6586671659336147e+00,	  -4.9654152287785562e+00,
	   2.5294949058414389e+00,	  -7.0527411450989808e-01,
	   8.3756479618678617e-02};

	const double
	RawEEGData::m_B[] =
	{3.4053765272014391e-04,	   2.0432259163208634e-03,
	   5.1080647908021588e-03,	   6.8107530544028782e-03,
	   5.1080647908021588e-03,	   2.0432259163208634e-03,
	   3.4053765272014391e-04};

	const int
	RawEEGData::m_FilterLength =
			sizeof(m_A)/sizeof(m_A[0]);

	void Arguments::ProcessSplitDirect(const int& argc,
		char *argv[])
	{
		const int lc_minArgs = 6;
		const int lc_maxArgs = 20;

		int channels[lc_maxArgs-lc_minArgs];
		double channels_data[lc_maxArgs-lc_minArgs];

		if(argc < lc_minArgs ||
			argc > lc_maxArgs){
			usage();
		}

		int noOfChannels = argc-lc_minArgs;

		const char* g_date = argv[4];
		const char* g_hour = argv[5];

		if(noOfChannels > 0){
			for(int i=0; i < noOfChannels; i++){
				channels[i] = (int) atof(argv[lc_minArgs + i]);
				cout << "Sampling : "<< channels[i] << endl;
			}
		}else{
			channels[0] = 0;
			noOfChannels = 1;
		}

		ifstream l_inputFile(argv[3]);
		// check if successfully opened  Patient data
		if (!l_inputFile.is_open ())
		{
			cout << "Error opening " << argv[3];
			exit (1);
		}else{
			cout << "\nProcessing " << argv[3] << endl;
		}

		ofstream l_outputFile("sample.txt", ios::app);

		char
		l_buffer[MAX_BUFFER_LEN];

		int rowIndex = 0;
		int sampleIndex = 0;

		cout << "-" << g_date << "-" << g_hour << "\n";

		while (!l_inputFile.eof ())
		{
			l_inputFile.getline (l_buffer, MAX_BUFFER_LEN);

			if(rowIndex < FRAME_LENGTH &&
				sampleIndex == 0) {
				// this array will contain channelData a_data
				istringstream input (l_buffer);
				// reading
				char l_date[32], l_hour[32];
				input >> l_date >> l_hour;

				// writing
				if(strcmp(g_date,l_date) == 0 &&
					g_hour[0] == l_hour[0] &&
					g_hour[1] == l_hour[1]){

						for(int i=0; i < NO_MONTAGES; i++){
							input >> channels_data[i];
						}

						for(int i=0; i < noOfChannels; i++){
							l_outputFile << channels_data[channels[i]] << "\t";
						}

						l_outputFile << "\n";
				}// end if date/hour matched sampling
			}// end if with data writing
			if(sampleIndex >= SAMPLE_SKIP){
				sampleIndex = 0;
				rowIndex = 0;
			}else if(rowIndex >=FRAME_LENGTH){
				rowIndex = 0;
				sampleIndex++;
			}else{
				rowIndex++;
			}
		}//end while
		l_inputFile.close();
		l_outputFile.close();
	}

	void Arguments::ProcessGenericArgs(const int& argc,
							char *argv[]){
		const int lc_minArgs = 7;
		if(argc < lc_minArgs){
			usage();
		}

		m_boolDebug = (strcmp(argv[1],"debug")==0)?true:false;

		if(strcmp(argv[2],"Trend") == 0){
			m_operationType = TREND;
		}else if(strcmp(argv[2],"Dump") == 0){
			m_operationType = DUMP;
		}else if(strcmp(argv[2],"Raw") == 0){
			m_operationType = RAW;
		}else if(strcmp(argv[2],"Single") == 0){
			m_operationType = SINGLE;
		}else if(strcmp(argv[2],"Split") == 0){
			m_operationType = SPLIT;
			this->ProcessSplitDirect(argc, argv);
			return;
		}//----------

		m_fileName = argv[3];

		m_decimation = (int) atof(argv[4]);

		m_vFactor = (int)atof(argv[5]);

		m_noOfCols = (int) atof(argv[6]);

		m_noOfIgnores = argc - lc_minArgs;

		if(m_noOfIgnores > 0){
			m_ignores = new int[argc - lc_minArgs];
			for(int i=0; i < m_noOfIgnores; i++){
				m_ignores[i] = (int) atof(argv[lc_minArgs+i]);
				cout << "Ignoring : "<< m_ignores[i] << endl;
			}
		}else{
			m_ignores = new int(-1);
		}

		if(m_operationType == TREND)
		{
			m_noOfsamples =(int)DCD_PERIOD;
		}else{
			m_noOfsamples = 1;
		}
	}

		/*!
		@name RawEEGData
		@brief A Function to clean member resources upon call
		@return
		*/

      RawEEGData::RawEEGData
		  (const Arguments& a_args):m_args(a_args)
	{
		p_rowTags = 0;

		p_inputFile.open (m_args.m_fileName);
		// check if successfully opened  Patient data
		if (!p_inputFile.is_open ())
		{
			cout << "Error opening\t" <<m_args.m_fileName<<"\t";
			exit (1);
		}else{
			cout << "\nProcessing:\t" << m_args.m_fileName << endl;
		}

		if(m_args.m_operationType == TREND){
			m_outFile.open ("Trend.txt", ios::app);
		}
		else if(m_args.m_operationType == DUMP){
			m_outFile.open ("Dump.txt", ios::app);
		}
		else if(m_args.m_operationType == SPLIT){
			m_outFile.open ("Split.txt", ios::app);
		}
		else if(m_args.m_operationType == RAW){
			m_outFile.open ("Raw.txt", ios::app);
		}
		else if(m_args.m_operationType == SINGLE){
			m_outFile.open ("Single.txt", ios::app);
		}
		else{
			m_outFile.open ("result.txt", ios::app);
		}
		m_timestampFile.open ("timestamp.txt", ios::app);
		m_headerFile.open ("header.txt", ios::app);

		// check if successful
		if (!m_outFile.is_open () ||
			!m_headerFile.is_open () ||
			!m_timestampFile.is_open ())
		{
			cout << "Error creating/opening output file";
			exit (1);
		}
		m_headerFile << "\n";
		m_timestampFile << "\n";
		// Create output file heading
		for (int i = 0;
			 i < NO_MONTAGES; i++)
		{
			const int x = g_montages[i][0];
			const int y = g_montages[i][1];
			// l_skip ignorechannels
			TEST_IGNORE_CHANNEL(x,y)

			m_headerFile
			<< g_channels[x-1].montage << "-"
			<< g_channels[y-1].montage << "\t" ;
		}

		m_headerFile << "\n";
		m_headerFile.flush();

		m_rowCounters = 0;
		m_meanFPE =0.0;
		m_meanOrder = 0.0;
		m_meanLength = 0.0;

		// start timer
		time (&g_startTime);
	}

		/*!
		@name ~RawEEGData
		@brief A Function to clean member resources upon call
		@return
		*/

	RawEEGData::~RawEEGData (void)
	{
	}

	void
	RawEEGData::finalize(void){
		time (&g_endTime);

		m_headerFile << "\n% Time taken in second: "
							<< g_endTime - g_startTime;

		m_headerFile << "\n% Resolution(# Samples): "
							<< m_args.m_noOfsamples;

		m_headerFile << "\n% Max AR Order: " << MAX_ARORDER;

		m_headerFile << "\n% Max Frame Length: " << FRAME_LENGTH;

		m_headerFile << "\n% Max Sample Period: "
							<< SAMPLE_PERIOD;

		m_headerFile << "\n% Decimation rate: "
							<< m_args.m_decimation;

		m_headerFile << "\n% (1:= uV 1000:= mV): "
							<< m_args.m_vFactor ;


		if(m_args.m_operationType == TREND ){

			if (m_rowCounters == 0) m_rowCounters = 1;

			m_headerFile << "\n% mean Ep/MAX_EP: "
				<< (m_meanFPE / double(m_rowCounters *
						NO_MONTAGES * m_args.m_noOfsamples)) ;

			m_headerFile << "\n% mean AR Order: "
				<< (m_meanOrder / double(m_rowCounters *
					NO_MONTAGES * m_args.m_noOfsamples)) <<"\n";

			m_headerFile
			<< "\n% mean Segment Length: "
			<< m_meanLength / (double(m_rowCounters) *
				double(NO_MONTAGES) * double(m_args.m_noOfsamples))<<"\n";
		}

		m_headerFile.flush();
		m_headerFile.close();
		p_inputFile.close ();

		m_outFile.flush();
		m_outFile.close ();

		m_timestampFile.flush();
		m_timestampFile.close();
		cout << "\ndone:\n";
		cout.flush();
	}
		/*!
		@name p_WriteDump
		@brief A Function to write used in dumping raw, preprocessed a_data
		@param a_data: is two dimensional array: Raw Data
		@return void
		*/
	void
	RawEEGData::p_WriteDump(const double a_data[NO_MONTAGES][FRAME_LENGTH],
					const char a_marker[FRAME_LENGTH][2][DATA_READ_LEN])
	{
		for(int row=0; row < FRAME_LENGTH; row++){
			m_outFile << a_marker[row][0] << "\t"
							<< a_marker[row][1] << "\t";
			for (int col = 0;
				col < NO_MONTAGES; col++)
			{
				const int x = g_montages[col][0];// source a_montage channel
				const int y = g_montages[col][1]; //  REF a_montage channel
				// l_skip ignorechannels
				TEST_IGNORE_CHANNEL(x,y)
				m_outFile << a_data[col][row]<< "\t";
			}
			m_outFile << "\n";
		}
	}

		/*!
		@name p_WriteSingle
		@brief A Function to write used in dumping raw, preprocessed a_data
		@param a_data: is two dimensional array: Raw Data
		@return void
		*/
	void
	RawEEGData::p_WriteSingle(const double a_data[NO_MONTAGES][FRAME_LENGTH],
					const char a_marker[FRAME_LENGTH][2][DATA_READ_LEN])
	{
		for(int row=0; row < FRAME_LENGTH; row++){
			m_timestampFile << a_marker[row][0] << "\t"
							<< a_marker[row][1] << "\n";
			// execute
			for(int i=0;
				i < NO_MONTAGES;i++)
			{
				const int x = g_montages[i][0];// source a_montage
				const int y = g_montages[i][1]; //  REF a_montage

				// l_skip ignorechannels
				TEST_IGNORE_CHANNEL(x,y)
				m_outFile << a_data[i][row]<< "\t";

			}
			m_outFile << "\n";
		}
	}

		/*!
		@name p_Write
		@brief A Function to write cepstrum analysis to text file
		@param a_slope: is two dimensional array holds (mx+c)value
		@param a_avg_FPE: is average final prediction error
		@return void
		*/

	void
	RawEEGData::p_Write(const double a_slopeCeps[NO_MONTAGES],
				const double a_slopeSpec[NO_MONTAGES],
				const double a_slopeRA[NO_MONTAGES],
				const double a_slopeSFR[NO_MONTAGES],
				const double a_slopeLength[NO_MONTAGES],
				const double a_slopeOrder[NO_MONTAGES],
				const double a_avgFPE[NO_MONTAGES],
				const double a_order[NO_MONTAGES],
				const double a_length[NO_MONTAGES],
				const char a_marker[FRAME_LENGTH][2][DATA_READ_LEN])
	{
		m_timestampFile << a_marker[0][0] << "\t"
			<< a_marker[0][1] << "\n";

		this->m_rowCounters++;

		// execute
		for(int i=0;
			i < NO_MONTAGES;i++)
		{
			const int x = g_montages[i][0];// source a_montage
			const int y = g_montages[i][1]; //  REF a_montage

			// l_skip ignorechannels
			TEST_IGNORE_CHANNEL(x,y)

			this->m_meanFPE += a_avgFPE[i];
			this->m_meanOrder += a_order[i];
			this->m_meanLength += a_length[i];

			m_outFile << a_slopeCeps[i] <<"\t"
					<< a_slopeSpec[i] <<"\t"
					<< a_slopeRA[i] <<"\t"
					<< a_slopeSFR[i] <<"\t"
					<< a_slopeLength[i] << "\t"
					<< a_slopeOrder[i] << "\t";
		}
		m_outFile << endl;
		m_outFile.flush();
		m_timestampFile.flush();
	}

		/*!
		@name p_Read
		@brief A Function to read 2D raw data from text file
		@param a_data: is two dimensional array holds channel data
		@return void
		This functions is constant if it is release version
		otherwise non const and dump sample result of each sub
		process to the output file
		*/
 int
	RawEEGData::p_Read (double a_data[NO_MONTAGES][FRAME_LENGTH],
						char a_marker[FRAME_LENGTH][2][DATA_READ_LEN])
	{
		char
			l_buffer[MAX_BUFFER_LEN];
  		int
			index = 0;
		unsigned long long
			l_oldTag = 0;
		bool
			l_jumpCounter = false;
		double
			l_data[REF][FRAME_LENGTH];

		while (!p_inputFile.eof () && index < FRAME_LENGTH)
		{
			p_inputFile.getline (l_buffer, MAX_BUFFER_LEN);

			// make sure first character is % for a comment
			if (l_buffer[0] != '%')
			{
				// This line ensures 4 sec sampling by toggling jum counter
				if(m_args.m_decimation == 2 && l_jumpCounter == true){
						l_jumpCounter = false;
						continue;
				}else{
					l_jumpCounter = true;
				}
				// this array will contain channelData a_data
				istringstream input (l_buffer);
				// formatted row marker from text l_buffer
				input >> a_marker[index][0] >> a_marker[index][1] >> p_rowTags;
				// now read consecutive 20 channelData
				for (int i = 1; i <= m_args.m_noOfCols; i++)
				{
					char
						l_dataBuffer[DATA_READ_LEN];
					input >> l_dataBuffer;
					TEST_IGNORE_CHANNEL(i,i) // redundant but simple
					if (strcmp (l_dataBuffer, "AMPSAT") == 0
					    || strcmp (l_dataBuffer,
						       "SHORT") == 0
					    || strcmp (l_dataBuffer,
						       "OFF") == 0)
					{
						index = -1;
						break;	// drop the line
					}
					l_data[i - 1][index] =
						double(atof (l_dataBuffer)) * this->m_args.m_vFactor;
					// may need math.h in windows
				}	// end for capturing 20 channel a_data

			}	//endif
			else{
				if(m_args.m_boolDebug == true){
					cout << l_buffer << "\n";
				}
				continue;
			}
			if ((index > 0 && p_rowTags == (l_oldTag + m_args.m_decimation)) || index == 0)
			{
				l_oldTag = p_rowTags;	// continue to read
			}
			else
			{
				index = 0;
				l_jumpCounter = false;
				continue;	// drop the frame
			}

			++index;

		}		//end while and FRAME_LENGTH
		// set the number of item read in this pass
		if(index < FRAME_LENGTH) return index; // terminate program
		this->p_ProcessMontages(a_data,l_data);
		return index;
	}

	void
	RawEEGData::p_DebugWrite(const double *a_data,
				const char*const a_fileName,
				const int& a_length)const
	{
		ofstream m_dbgFile(a_fileName);
		if (!m_dbgFile.is_open ())
		{
			cout << "\nError opening\t" << a_fileName << "\n";
			return;
		}
		for (int x = 0; x < a_length; x++)
			m_dbgFile << a_data[x] << " ";
		m_dbgFile << "\n";
		m_dbgFile.flush();
		m_dbgFile.close();
	}
		/*!
		@name p_PreProcess
		@brief A Function to preprocess raw data
		@param a_data: is two dimensional array holds channel data
		@return void
		This functions is constant if it is release version
		otherwise non const and dump sample result of each sub
		process to the output file
		*/

	void
	RawEEGData::p_PreProcess(double a_data[FRAME_LENGTH])const
	{
		// This frame is ready for further processing
		INIT_DEBUG_PRINT()

		EXEC_DEBUG_PRINT(a_data, FRAME_LENGTH, "raw.txt")

		this->p_DcRemove (a_data);

		EXEC_DEBUG_PRINT(a_data, FRAME_LENGTH, "dc.txt")

		this->p_RemoveBLW (a_data);

		EXEC_DEBUG_PRINT(a_data, FRAME_LENGTH, "blw.txt")

		const int a_noelements=MA_POINTS;
		this->p_MAFilter (a_data, a_noelements );

		EXEC_DEBUG_PRINT(a_data, FRAME_LENGTH, "ma.txt")

		for(int i=0;i<FRAME_LENGTH;i+=BASE_FREQ)
			this->
			p_Filter(&a_data[i],BASE_FREQ, m_A, m_B, m_FilterLength);

		EXEC_DEBUG_PRINT(a_data, FRAME_LENGTH, "butter6.txt")

		this->p_HanningCorrection(a_data, FRAME_LENGTH);

		EXEC_DEBUG_PRINT(a_data, FRAME_LENGTH,"hanncorec.txt")

		this->p_FilterByFFT(a_data);
		this->p_DcRemove(a_data);

		EXEC_DEBUG_PRINT(a_data, FRAME_LENGTH, "final.txt")

		FINALIZE_DEBUG_PRINT()
	}// end preprocess

	void
	RawEEGData::p_ProcessMontages(double a_montage[NO_MONTAGES][FRAME_LENGTH],
					double a_data[REF][FRAME_LENGTH])const
	{
		// Create Montages
		for(int i=0;
			i < NO_MONTAGES;i++)
		{
			const int x = g_montages[i][0]-1;// source a_montage
			const int y = g_montages[i][1]-1;//  REF a_montage

			for(int j=0;j< FRAME_LENGTH; j++)
			{
				const double ref = a_data[y][j];
				a_montage[i][j] = a_data[x][j] - ref;
			}

			INIT_DEBUG_PRINT()
			EXEC_DEBUG_PRINT(a_data[x], FRAME_LENGTH, "X.txt")
			EXEC_DEBUG_PRINT(a_data[y], FRAME_LENGTH, "Y.txt")
			FINALIZE_DEBUG_PRINT()

		}// end for loop
	}// end p_ProcessMontages


	/*!
	@name Process
	@brief A Function to process Cepstrum analysis
	@param void
	@return void
	*/
void
RawEEGData::Process(void)
{
	double x_cord[DCD_PERIOD];
	// cepstrum for each frame
	double ceps[NO_MONTAGES][DCD_PERIOD];
	double spec[NO_MONTAGES][DCD_PERIOD];
	double ra[NO_MONTAGES][DCD_PERIOD];
	double sfr[NO_MONTAGES][DCD_PERIOD];
	double flength[NO_MONTAGES][DCD_PERIOD]; // new parameter
	double forder[NO_MONTAGES][DCD_PERIOD];  // new parameter

	// consecutive input a_data
	double l_data[NO_MONTAGES][FRAME_LENGTH];
	char  l_marker[FRAME_LENGTH][2][DATA_READ_LEN];

 	int
		second = 0;
	while (!p_inputFile.eof () &&
			this->p_Read (l_data, l_marker) == FRAME_LENGTH)
	{
		double l_arorder[NO_MONTAGES];
		double l_avgFPE[NO_MONTAGES];
		double l_length[NO_MONTAGES];

		if(second == 0){
			memset(l_arorder,0,sizeof(l_arorder));
			memset(l_avgFPE,0,sizeof(l_avgFPE));
			memset(l_length,0,sizeof(l_length));
		}//end if

		for(int i=0;
			i < NO_MONTAGES;i++)
		{
			const int x = g_montages[i][0];// source a_montage
			const int y = g_montages[i][1]; //  REF a_montage

			// l_skip ignorechannels
			TEST_IGNORE_CHANNEL(x,y)
			this->p_PreProcess(l_data[i]);
			// Now do the analysis
			double 	Ao[MAX_ARORDER + 1];
			int order = 0;
			double length=0.0;
			double perform=0.0;
			double l_Ep = 0.0;
			double l_wgn[FRAME_LENGTH];

			ceps[i][second] =
			this->
			p_SumOfCepstrums(l_data[i],
					l_wgn,
					Ao,
					l_Ep,
					length,
					order,
					perform);

			l_avgFPE[i] += perform;
			l_arorder[i] += order;
			l_length[i] += length;

			flength[i][second] = length;
			forder[i][second] = order;

			// Provides both RA and spectrum
			spec[i][second] =
			this->
			p_SumOfSpectrum(Ao,
					l_Ep,
					length,
					order,
					ra[i][second]);

			const int wgn_length = int((length / SAMPLE_PERIOD) *
					FRAME_LENGTH);
			sfr[i][second] =
			this->
			p_wgnSFR(l_wgn,
				wgn_length);

			INIT_DEBUG_PRINT()
			EXEC_DEBUG_PRINT(l_wgn,wgn_length,"residualX.txt")
			FINALIZE_DEBUG_PRINT()
		}

		const double periodOffset = double(SAMPLE_PERIOD)/2;

		if (second == (m_args.m_noOfsamples -1) )
		{
			// initialized first element
			x_cord[0] = periodOffset;
			// Results
			double l_slopeCeps[NO_MONTAGES];
			double l_slopeSpec[NO_MONTAGES];
			double l_slopeRA[NO_MONTAGES];
			double l_slopeSFR[NO_MONTAGES];
			double l_slopeLength[NO_MONTAGES];
			double l_slopeOrder[NO_MONTAGES];

			INIT_DEBUG_PRINT()
			EXEC_DEBUG_PRINT(x_cord, m_args.m_noOfsamples,
			"Xinterpolate.txt")

			for (int i = 0;
					i < NO_MONTAGES; i++)
			{
				const int x = g_montages[i][0];// source a_montage
				const int y = g_montages[i][1]; //  REF a_montage

				// l_skip ignorechannels
				TEST_IGNORE_CHANNEL(x,y)
				EXEC_DEBUG_PRINT(ra[i], m_args.m_noOfsamples, "alpha.txt")
				EXEC_DEBUG_PRINT(spec[i], m_args.m_noOfsamples, "spec.txt")
				EXEC_DEBUG_PRINT(ceps[i], m_args.m_noOfsamples, "ceps.txt")
				EXEC_DEBUG_PRINT(sfr[i], m_args.m_noOfsamples, "sfr.txt")
				EXEC_DEBUG_PRINT(flength[i], m_args.m_noOfsamples, "flength.txt")
				EXEC_DEBUG_PRINT(forder[i], m_args.m_noOfsamples, "forder.txt")
				FINALIZE_DEBUG_PRINT()

				double l_result[2] = { 0.0, 0.0 }; // used to interpolate
				// Next RA
				INTERPOLATE_FEATURE(ra[i], l_slopeRA[i])
				//
				// Next ceps
				INTERPOLATE_FEATURE(ceps[i], l_slopeCeps[i])
				//
				// Next Spec
				INTERPOLATE_FEATURE(spec[i], l_slopeSpec[i])
				//
				// Next SFR
				INTERPOLATE_FEATURE(sfr[i], l_slopeSFR[i])
				// Next flength
				INTERPOLATE_FEATURE(flength[i], l_slopeLength[i])
				// Next forder
				INTERPOLATE_FEATURE(forder[i], l_slopeOrder[i])

			}// end for
			// now write them to text fil
			this->p_Write(l_slopeCeps,l_slopeSpec, l_slopeRA,
						 l_slopeSFR,l_slopeLength, l_slopeOrder,
					l_avgFPE, l_arorder, l_length, l_marker);
			second = 0;
		} // if
		else
		{// This code ensures proper timing
			// axis - X axis
			x_cord[second] = (double)p_rowTags;
			if (second > 0)
			{
				x_cord[second] -= x_cord[0];
				x_cord[second] = (double)floor(x_cord[second] / double(FRAME_LENGTH)
							* double(SAMPLE_PERIOD) + periodOffset);
			}
			second++;
		} // else
	}// end while
}// end process function


		/*!
		@name ProcessDump
		@brief A Function to dump preprocess data no analysis
		@param void
		@return void
		*/

	void
	RawEEGData::ProcessDump(void)
	{
		// consecutive input a_data
		double l_data[NO_MONTAGES][FRAME_LENGTH];
		char  l_marker[FRAME_LENGTH][2][DATA_READ_LEN];
		while (!p_inputFile.eof () &&
				this->p_Read (l_data, l_marker) == FRAME_LENGTH)
		{
			// execute
			for(int i=0;
				i < NO_MONTAGES;i++)
			{
				const int x = g_montages[i][0];// source a_montage
				const int y = g_montages[i][1]; //  REF a_montage

				// l_skip ignorechannels
				TEST_IGNORE_CHANNEL(x,y)
				this->p_PreProcess(l_data[i]);
			}
			this->p_WriteDump(l_data, l_marker);
		}
	}

		/*!
		@name ProcessSingle
		@brief A Function to dump preprocess data no analysis
		@param void
		@return void
		*/

	void
	RawEEGData::ProcessSingle(void)
	{
		// consecutive input a_data
		double l_data[REF][FRAME_LENGTH];
		char  l_marker[FRAME_LENGTH][2][DATA_READ_LEN];
		while (!p_inputFile.eof () &&
				this->p_Read (l_data, l_marker) == FRAME_LENGTH)
		{
			// execute
			for(int i=0;
				i < NO_MONTAGES;i++)
			{
				const int x = g_montages[i][0];// source a_montage
				const int y = g_montages[i][1]; //  REF a_montage

				// l_skip ignorechannels
				TEST_IGNORE_CHANNEL(x,y)
				this->p_PreProcess(l_data[i]);
			}

			this->p_WriteSingle(l_data, l_marker);
		}
	}
		/*!
		@name ProcessRaw
		@brief A Function to dump unprocessed data no analysis
		@param void
		@return void
		*/

	void
	RawEEGData::ProcessRaw(void)
	{
		// consecutive input a_data
		double l_data[NO_MONTAGES][FRAME_LENGTH];
		char  l_marker[FRAME_LENGTH][2][DATA_READ_LEN];
		while (!p_inputFile.eof () &&
			this->p_Read (l_data, l_marker) == FRAME_LENGTH)
		{
			this->p_WriteDump(l_data, l_marker);
		}
	}


	void
	RawEEGData::p_DcRemove (double a_data[FRAME_LENGTH]) const
	{
		double	sum = 0.0;

		for (int index = 0;index < FRAME_LENGTH; index++)
			sum += a_data[index];

		double	average = sum / FRAME_LENGTH;
		// correct the dc value in the frame
		for (int index = 0;index < FRAME_LENGTH; index++)
			a_data[index] -= average;

	}			// end function dcRemove


	void
	RawEEGData::p_MAFilter (double a_data[FRAME_LENGTH],
				const int& a_noelements) const
	{
		// The FIFO that will hold the a_data for MA Filter @ 50 Hz
		double* fittedFrame = new double[a_noelements+1];

		for(int i=0; i < a_noelements+1; i++)
			fittedFrame[i] = 0;

		// calculate first element
		fittedFrame[0] = a_data[0];

		double	sum = fittedFrame[0];

		a_data[0] = sum / a_noelements ;
		// y(n) := y(n-1) + [x(n)-x(n-p)]/p
		int	index = 1;
		for (int i = 1; i < FRAME_LENGTH; i++)
		{
			fittedFrame[index] = a_data[i];
			// this saves 2.1% processing time
			const int lastFrame = (index  == a_noelements)
						 ? 0: (index + 1);
			a_data[i] = a_data[i-1] +
				(fittedFrame[index] -
				fittedFrame[lastFrame])/a_noelements;
			if (++index == a_noelements+1)
				index = 0;
		}

		delete[] fittedFrame; fittedFrame = NULL;
	}//end function


	void
	RawEEGData::p_PolyVal (const double a_X[],
					double a_Y[],
				     	const int& a_length,
					const int &a_order,
				     	const double a_result[]) const
	{
		for (int i = 0; i < a_length; i++)
		{
			a_Y[i] = 0;
			double
				p = 1;
			for (int ord = 0; ord < a_order + 1; ord++)
			{
				a_Y[i] += a_result[ord] * p;
				p    *=	a_X[i];
			}
		}
	}//end function


	void
	RawEEGData::p_PolyFit (const double a_X[],
				   const double a_Y[],
				   const int &a_length,
				   const int &a_order,
				   double a_result[])const
	{
		if(a_order > POLYNOMIAL_ORDER) exit(1);

		double*	 elements = new double[2 * a_order + 1];
		for(int i=0;i<(2*a_order+1); i++)
			elements[i] = 0.0;

		elements[0] = (double)a_length;

		double*	 a_A[POLYNOMIAL_ORDER + 1];

		for(int i=0;i<a_order+1;i++){
			a_A[i] = new double[a_order + 2];
			a_result[i] = 0.0;
			for(int j=0;j<(a_order + 2);j++)
				a_A[i][j] = 0.0;
		}

		//  create column vector and x_(K-1)
		for (int k = 0; k < a_length; k++)
		{
			const double &
				yy = a_Y[k];
			const double &
				xx = a_X[k];
			double
				p = 1;	// col vector

			for (int r = 0; r < a_order + 1; r++)
			{
				// a_B[0] = a_B[0]+Y1* 1, a_B[1] = a_B[1] + Y1 * a_X[1]
				a_A[r][a_order + 1] += yy * p;
				// a_B[2] = a_B[2] + a_Y[1]*a_X[1]*a_X[1]
				p = p * xx;
			}

			//Compute the sum of powers of x_(K-1)
			p = xx;
			for (int i = 1; i < 2 * a_order + 1; i++)
			{
				elements[i] += p;
				p = p * xx;
			}
		}

		//Determine the matrix entries

		for (int row = 0; row < a_order + 1; row++)
			for (int col = 0; col < a_order + 1; col++)
				a_A[row][col] = elements[row + col];

		//  Solve the linear system of M_ORDER + 1 equations

  		int* 	Row = new int[a_order + 1];	// Field with row-number

		//Initialize the polonger vector

		for (int i = 0; i < a_order + 1; i++)
			Row[i] = i;

		// Start LU factorization

		for (int p = 0; p < a_order + 1; p++)
		{
			// Find pivot element

			for (int k = p + 1; k < a_order + 1; k++)
			{
				if (fabs (a_A[Row[k]][p]) > fabs (a_A[Row[p]][p]))
				{
				     int t = Row[p];
					Row[p] = Row[k];
					Row[k] = t;
				}
			}	// simulate row longerchange

			if (a_A[Row[p]][p] == 0)
			{
				cout << "\nA[" << Row[p] << "][" << p
					 << "]:\t" << a_A[Row[p]][p]
					 << "\nThe matrix is SINGULAR !";
				return;
			}
			// Form multiplier

			for (int k = p + 1; k < a_order + 1; k++)
			{
				// scale the ith column of the matrix
				// a_A[Row[p][p] is the pivot element
				a_A[Row[k]][p] = a_A[Row[k]][p] / a_A[Row[p]][p];

				// Eliminate
				for (int c = p + 1; c < a_order + 2; c++)
				{
					a_A[Row[k]][c] -=
						a_A[Row[k]][p] * a_A[Row[p]][c];
				}
//         a_A[Row[K]][P] = 0;
			}
		}		// End of  L*U  factorization routine
// now need forward substitution
		for (int i = 0; i < a_order + 1; i++)
		{
			for (int j = i + 1; j < a_order + 2; j++)
			{
				a_A[Row[i]][j] /= a_A[Row[i]][i];
			}
//              a_A[Row[i]][i] = 1;
		}

// now back substitution
  		int
			factorCol = 0;
		for (int k = a_order; k >= 0; k--)
		{
			const double &
				pivot = a_A[Row[k]][a_order + 1];

			factorCol++;
			for (int j = a_order - factorCol; j >= 0; j--)
			{
				const double &
					a_mvFactor =
					a_A[Row[j]][a_order + 1 - factorCol];
				for (int col = 0; col < factorCol; col++)
				{
					a_A[Row[j]][a_order + 1 - col] -=
						a_mvFactor * pivot;
				}
			}
		}

		for (int i = 0; i < a_order + 1; i++)
			a_result[i] = a_A[Row[i]][a_order + 1];

		delete[] elements; elements = NULL;
		delete[] Row; Row = NULL;
		for(int i=0;i<a_order+1;i++){
			delete[] a_A[i]; a_A[i] = NULL;
		}
	}// end function


	void
	RawEEGData::p_RemoveBLW (double a_data[FRAME_LENGTH])const
	{
		double*	x_cord = new double[FRAME_LENGTH];
		const double offset = 0.5/double(FRAME_LENGTH);
		for (int i = 0; i < FRAME_LENGTH; i++){
			x_cord[i] =
			(double(i)/FRAME_LENGTH)*double(SAMPLE_PERIOD) + offset;
		}

		INIT_DEBUG_PRINT()
		EXEC_DEBUG_PRINT(x_cord, FRAME_LENGTH, "Xblw.txt")
		FINALIZE_DEBUG_PRINT()

		double*	l_result = new double[POLYNOMIAL_ORDER + 1];
		this->p_PolyFit (x_cord, a_data, FRAME_LENGTH,
			       POLYNOMIAL_ORDER, l_result);

		double*	correctedChannelData = new double[FRAME_LENGTH];
		p_PolyVal (x_cord, correctedChannelData,FRAME_LENGTH,
				 POLYNOMIAL_ORDER, l_result);

		// correct the low freq noise
		for (int index = 0; index < FRAME_LENGTH; index++)
			a_data[index] -=
				correctedChannelData[index];

		delete[] correctedChannelData; correctedChannelData = NULL;
		delete[] x_cord; x_cord = NULL;
		delete[] l_result; l_result = NULL;
	}//end function

	void
	RawEEGData::p_HanningCorrection(double a_data[FRAME_LENGTH],
					const int& a_length) const
	{
		// Removing edges with 5% hanning taper
		int hann_len = a_length/10+1;
		for(int x = 1;x < int(hann_len/2);x++){
			double hann_coef = 0.5*(1 - cos(2*M_PI*x/hann_len));
			a_data[x-1] = a_data[x-1] * hann_coef;
			a_data[FRAME_LENGTH-x] =
				a_data[FRAME_LENGTH-x] * hann_coef;
		}
	}

	/*!
	@name p_FilterByFFT
	@brief Search and look for its use ! :)
	@param a_data 1D array upon which function will operate
	@return void
	This function uses FFT to remove Low and High Frequency
	0.5hz <= f <= 32 hz
	*/
	void
	RawEEGData::p_FilterByFFT(double a_data[FRAME_LENGTH])const
	{
		FILE *wisdom;
		static fftw_plan p1, p2;
		static fftw_complex h[FRAME_LENGTH], H[FRAME_LENGTH];

		/* Keep the arrays and plans around from last time, since this
		is a very common case. Reallocate them if they change. */
		INIT_DEBUG_PRINT()
		if (firstTime) {
			/* Get any accumulated wisdom. */
			wisdom = fopen("wisfile", "r");
			if (wisdom) {
				fftw_import_wisdom_from_file(wisdom);
				fclose(wisdom);
			}

			/* Set up the fftw plans. */
			p1 = fftw_plan_dft_1d(FRAME_LENGTH, h, H,
								FFTW_FORWARD,FFTW_MEASURE );
			p2 = fftw_plan_dft_1d(FRAME_LENGTH, H, h,
								FFTW_BACKWARD, FFTW_MEASURE);
			/* Save the wisdom. */
			wisdom = fopen("wisfile", "w");
			fftw_export_wisdom_to_file(wisdom);
			fclose(wisdom);
		}
		// do not need to recreate the plan
		FINALIZE_DEBUG_PRINT()

		/* Convert the input to complex. Also compute the mean. */
		for (int x = 0; x < FRAME_LENGTH; x++) {
			h[x][0] = a_data[x];
			h[x][1] = 0.0;
		}

		/* FFT. */
		fftw_execute(p1);

		// Filter high & Very lowFrequency component
		for (int x = 0; x < 2; x++) {
			H[x][0] = 0.0;
			H[x][1] = 0.0;
		}

		for (int x = 128; x < FRAME_LENGTH; x++) {
			H[x][0] = 0.0;
			H[x][1] = 0.0;
		}

		fftw_execute(p2);

		/* Convert the output to real. */
		for(int j=0;j<FRAME_LENGTH;j++){
			a_data[j] = h[j][0]/FRAME_LENGTH;
		}
	}

#define MIN_DESC_LENGTH(var, order, length) fabs(var*log(order+1) + var*log((double)length))
#define MIN_LENGTH_ORDER(var, order, length) fabs(log(((1+ order/length)/(1-order/length))*var))
#define AIC_CRIT(var,order,length) fabs(log(var)+(length+order)/(length-order-2))

        int
	RawEEGData::p_GetOptimumAR(const double a_data[FRAME_LENGTH],
					double a_wgn[FRAME_LENGTH],
					double* a_AR,
					double& a_Ep,
					int& a_order,
					double& a_perform)const
	{
		// This is performance criteria, i.e. Variance
		double 	Ao[MAX_ARORDER + 1];

		a_order =
		this->p_ArBurg(a_data, a_wgn, Ao, a_perform, a_Ep, FRAME_LENGTH);

		int last_length = FRAME_LENGTH;

		double last_MDL = MIN_DESC_LENGTH(a_perform,a_order,last_length);

		const double DELTA_LENGTH = 10;
		const double MINIMUM_LENGTH = 900;
		// Calculate Optimum AR parameters
		const int limit_test = int(FRAME_LENGTH / DELTA_LENGTH);

		const int start_polong = int(MINIMUM_LENGTH / DELTA_LENGTH);

		for(int i = limit_test - 1;
				i > start_polong; i--)
		{
			// Store the last known good values
			for(int j=0; j < MAX_ARORDER; j++){
				a_AR[j] = Ao[j];
			}

			const int a_length = int(i * DELTA_LENGTH);

			a_order = this->p_ArBurg(a_data, a_wgn, Ao, a_perform, a_Ep, a_length);

			const double perf = a_length * a_perform / double(FRAME_LENGTH);

			double cur_MDL = MIN_DESC_LENGTH(perf, a_order, a_length);

			if(cur_MDL > last_MDL) break;

			last_MDL = cur_MDL;

			last_length = a_length;
		}
		return last_length;
	}

	double
	RawEEGData::p_SumOfSpectrum(const double* a_AR,
					const double& a_Ep,
					const double& a_length,
					const int& a_order,
					double& a_frameRA)const

	{
		const double MAX_FREQ = .128;
		const double MIN_FREQ = .008;
		const double DELTA_FREQ = .002;
		const int l_power_length =
			int((MAX_FREQ - MIN_FREQ)/DELTA_FREQ);
		double l_sumFreq=0.0;

		// 1/250, 20/250
//		const double RA_BASE_MIN = .004;
//		const double RA_BASE_MAX = .08;
//		double l_ra_base = 0.0;
		// 6/250, 14/250
		const double RA_MIN_FREQ = .024;
		const double RA_MAX_FREQ = .056;
		const int l_ra_length =
			int((RA_MAX_FREQ - RA_MIN_FREQ)/DELTA_FREQ);
		double l_ra = 0.0;

		double* l_power = new double[l_power_length];
		double* l_freq = new double[l_power_length];

		int index = 0;
		double gmean_F = 0;
		double l_ra_gmean = 0;

		for(double x = MIN_FREQ; x < MAX_FREQ; x+=DELTA_FREQ){
			double l_real = 1;
			double l_imaginary = 0;

			for (int i = 1; i <= a_order; i++)
			{
				l_real += a_AR[i] * cos(x * i * a_length);
				l_imaginary += a_AR[i] * sin(x* i * a_length);
			}
			complex<double> l_cmplx_pwr(l_real,l_imaginary);

			// Normalized power spectrum amplitude
			l_cmplx_pwr = (a_Ep * a_length)/(l_cmplx_pwr * l_cmplx_pwr);

			const double curPower = abs(l_cmplx_pwr);

			const double logPower = log(curPower);

			l_power[index] = 10*log10(curPower);
			l_freq[index++] = x;

			l_sumFreq += curPower;

			if(x >= RA_MIN_FREQ && x <= RA_MAX_FREQ) {
				l_ra += curPower;
				l_ra_gmean += logPower;
			}
			l_sumFreq += curPower;
			gmean_F += log(curPower);
		}
		l_sumFreq /= l_power_length;
		gmean_F /= l_power_length;
		l_ra /= l_ra_length;
		l_ra_gmean /= l_ra_length;

		INIT_DEBUG_PRINT()
		EXEC_DEBUG_PRINT(l_power,l_power_length,"Pf.txt")
		EXEC_DEBUG_PRINT(l_freq,l_power_length,"freq.txt")
		FINALIZE_DEBUG_PRINT()

		delete[] l_power;l_power=NULL;
		delete[] l_freq; l_freq = NULL;
		// dont use the ratio
		a_frameRA = ( 10*log10(exp(l_ra_gmean)/l_ra));
		return ( 10*log10(exp(gmean_F)/l_sumFreq));
	}

	double
	RawEEGData::p_wgnSFR(double a_data[FRAME_LENGTH],
				const int& a_length)const
	{
		FILE *wisdom;
		static fftw_plan p1;
		static fftw_complex h[FRAME_LENGTH], H[FRAME_LENGTH];

		/* Keep the arrays and plans around from last time, since this
		is a very common case. Reallocate them if they change. */
		INIT_DEBUG_PRINT()
		if (firstTime) {
			/* Get any accumulated wisdom. */
			wisdom = fopen("wisfile", "r");
			if (wisdom) {
				fftw_import_wisdom_from_file(wisdom);
				fclose(wisdom);
			}

			/* Set up the fftw plans. */
			p1 = fftw_plan_dft_1d(FRAME_LENGTH, h, H,
								FFTW_FORWARD,FFTW_MEASURE );
			/* Save the wisdom. */
			wisdom = fopen("wisfile", "w");
			fftw_export_wisdom_to_file(wisdom);
			fclose(wisdom);
		}
		// do not need to recreate the plan
		FINALIZE_DEBUG_PRINT()

		/* Convert the input to complex. Also compute the mean. */
		for (int x = 0; x < FRAME_LENGTH; x++) {
			if(x < a_length){
				h[x][0] = a_data[x];
				h[x][1] = 0.0;
			}else{
				h[x][0] = 0.0;
				h[x][1] = 0.0;
			}
		}

		/* FFT. */
		fftw_execute(p1);

		double l_sumFreq = 0.0;
		double gmean_F = 0.0;
		for (int x = 0; x < FRAME_LENGTH; x++) {
			complex<double> l_cmplx_pwr(H[x][0],H[x][1]);

			const double curPower = abs(l_cmplx_pwr);

			l_sumFreq += curPower;
			gmean_F += log(curPower);
		}
		l_sumFreq /= FRAME_LENGTH;
		gmean_F /= FRAME_LENGTH;
		return( 20*log10(exp(gmean_F)/l_sumFreq));
	}

	double
	RawEEGData::p_SumOfCepstrums (const double a_data[FRAME_LENGTH],
					double a_wgn[FRAME_LENGTH],
					double* a_AR,
					double& a_Ep,
					double& a_length,
					int& a_order,
					double& a_perform)const
	{
		// This is suppose to be int
		a_length
		= double(this->
		p_GetOptimumAR(a_data, a_wgn, a_AR, a_Ep, a_order, a_perform))
		*double(SAMPLE_PERIOD)/double(FRAME_LENGTH);

	// Now Calculates Cepstrum coefficients upto LowestOrder+1
		INIT_DEBUG_PRINT()

		a_AR[0] = a_length;

		EXEC_DEBUG_PRINT(a_AR, int(a_order+1), "Ao.txt")

		a_AR[0] = 1;

		double	l_Cep[MAX_ARORDER + 2];	// leave it as is

		double a_result = p_ArCeps(a_AR, l_Cep, a_order+2);

		EXEC_DEBUG_PRINT(l_Cep, int(a_order+2), "arceps.txt")

		FINALIZE_DEBUG_PRINT()

		return a_result;
	}// end function

	// This code calculates Ar Coefficients
	// MAX_ARORDER is a const set to 12
	// fpeData is tha variance
	const int
	RawEEGData::p_ArBurg(const double a_data[FRAME_LENGTH],
				double a_wgn[FRAME_LENGTH],
				double a_Ar[MAX_ARORDER+1],
				double& a_fpeData,
				double& a_Ep,
				const int& a_length) const
	{
		double	Ao[MAX_ARORDER + 1];
		double  Bo[MAX_ARORDER + 1];

		for(int i=0;i<=MAX_ARORDER; i++)
			Ao[i] = a_Ar[i] = Bo[i] = 0.0;

		// Forward Prediction Error - used recursively
		double	Fe[MAX_ARORDER+1][FRAME_LENGTH+1];

		// Backward Prediction Error - used recursively
		double	Be[MAX_ARORDER][FRAME_LENGTH+1];

		for(int i=0;i<=MAX_ARORDER; i++){
			Ao[i] = a_Ar[i] = 0.0;
			for(int j=0;j<=FRAME_LENGTH;j++)
				Fe[i][j] = Be[i][j] = 0.0;
		}


		double Eo = 0.0; // variance
		a_Ep = 0.0; // mean of white noise
		for (int n = 0; n < a_length; n++)
		{
			Eo += a_data[n] * a_data[n];
			Fe[0][n+1] = Be[0][n+1] = a_data[n];
			a_Ep += fabs(a_data[n]);
		}
		// MSE
		Eo /= a_length;
		a_Ep /= a_length;

		int	lowestOrder = MAX_ARORDER;

		// Monotonically punished by Order
		double cur_fpe_criteria = MIN_DESC_LENGTH(Eo,0,a_length);
		double last_fpe_criteria = cur_fpe_criteria;

		double	den = 0.0 ;

		for (int m = 1; m <= MAX_ARORDER; m++)
		{
			Ao[0] = a_Ar[0] = 1;
			den = Ao[m] = 0.0; // same as Km

			for (int n = m+1 ; n <= a_length; n++)
			{
				// Numerator
				Ao[m] += Fe[m-1][n] * Be[m-1][n - 1];
				den += Be[m-1][n - 1] * Be[m-1][n - 1] +
					Fe[m-1][n] * Fe[m-1][n];
			}

			Ao[m] = Ao[m] * (-2) / den;

			a_fpeData = Eo;

			Eo = (1 - Ao[m] * Ao[m]) * Eo;

			// now sets AR coefficients for order m
			for (int i = 1; i <= m - 1; i++){
				Ao[i] =
				a_Ar[i] + Ao[m] * a_Ar[m - i];
			}
			// Select the order and exit
			cur_fpe_criteria =
				MIN_DESC_LENGTH(Eo, m, a_length);

			if(Eo < 0 || fabs(Ao[m]) > 1  // Stability test
				|| (cur_fpe_criteria > last_fpe_criteria &&
				m > MIN_ARORDER))
			{
				lowestOrder = m -1;
				break;
			}else{
				last_fpe_criteria = cur_fpe_criteria;
			}
			// Calculate Forward/Backward Error & Ep
			a_Ep = 0.0;
			double temp = 0;
			double Befactor = 0;
			for (int n = 1; n <= a_length - m; n++)
			{
//				temp = Be[n];
				Be[m][n] = Be[m-1][n-1] + Ao[m] * Fe[m-1][n];
				Fe[m][n] = Fe[m-1][n] + Ao[m] * Be[m-1][n-1];
				a_Ep += fabs(Fe[m][n]) + fabs(Be[m][n]);
//				Befactor = temp;
			}
			// rest of them has zero error
			for(int n = a_length - m +1; n <= a_length; n++){
				Fe[m][n] = Be[m][n] = 0.0;
			}

			for(int i=0; i <= lowestOrder; i++){
				a_Ar[i] = Ao[i];
			}
			a_Ep /= (2*(a_length-1)); // mean error
		}// end max arorder

		Bo[0]=1;
		// inverse filter to get residual
		this->p_Filter(a_wgn,a_length, Bo, a_Ar, lowestOrder+1);

		this->p_HanningCorrection(a_wgn, a_length);

		a_fpeData = (a_Ep/MAX_EP);

//		delete[] Fe; Fe = NULL;
//		delete[] Be; Be = NULL;
		return lowestOrder;
	} //  end function p_ArBurg

// Filter constants a_A and a_B must be of same a_length

	void
	RawEEGData::p_Filter(double* a_data,
				const int& len,
				const double* a_A,
				const double* a_B,
				const int& a_FilterLength)const
	{
		double* l_X=new double[a_FilterLength];
		double* l_Y=new double[a_FilterLength];

		// initialize the circular FIFO
		for(int i=0; i < a_FilterLength;i++)
			l_Y[i] = l_X[i] = 0.0;

		int butter_b_index = 0;
		int index = 0;
		double l_num = 0.0;
		for(int x = 0; x < len;x++){
			// it is still unmodified
			l_X[butter_b_index] = a_data[x];

			index = butter_b_index;

			l_num = a_B[0]*l_X[index];

			if(--index < 0)
				index = a_FilterLength -1;
			// using difference equation
		 	for(int i=1; i < a_FilterLength; i++){
				l_num += (a_B[i]*l_X[index] - a_A[i]*l_Y[index]);
				// wrap around :)
				if(--index < 0)
					index = a_FilterLength -1;
			}
			l_Y[butter_b_index] = l_num;

			a_data[x] = l_Y[butter_b_index];
			// wrap around :)
			if(++butter_b_index == a_FilterLength)
				butter_b_index = 0;
		} //  end processing filtering
		delete[] l_X;l_X=NULL;
		delete[] l_Y;l_Y=NULL;
	}//end function

	double
	RawEEGData::p_ArCeps(const double a_Ar[MAX_ARORDER+1],
				double a_ceps[MAX_ARORDER+2],
				const int& a_order) const
	{
		a_ceps[0] = 0.0;

		double l_Sumc = fabs(a_ceps[0]);

		for (int i = 1; i <= a_order; i++)
		{
			a_ceps[i] = a_Ar[i];
			for (int k = 1; k < i; k++)
			{
				a_ceps[i] +=
				double(k) / double(i) * a_ceps[k] * a_Ar[i-k];
			}
			a_ceps[i] *= -1;
			l_Sumc += fabs (a_ceps[i]);
		}
		return l_Sumc;
	}
}// end namespace
